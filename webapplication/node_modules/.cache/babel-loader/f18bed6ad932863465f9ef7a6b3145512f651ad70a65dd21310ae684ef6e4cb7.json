{"ast":null,"code":"import React, { useState, useReducer, useMemo, useCallback, useEffect, useContext, useRef, useLayoutEffect, forwardRef, useImperativeHandle, Children } from 'react';\nimport { createPortal } from 'react-dom';\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nconst APILoadingStatus = {\n  NOT_LOADED: 'NOT_LOADED',\n  LOADING: 'LOADING',\n  LOADED: 'LOADED',\n  FAILED: 'FAILED',\n  AUTH_FAILURE: 'AUTH_FAILURE'\n};\nconst MAPS_API_BASE_URL = 'https://maps.googleapis.com/maps/api/js';\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */\nclass GoogleMapsApiLoader {\n  /**\n   * Loads the Google Maps API with the specified parameters.\n   * Since the Maps library can only be loaded once per page, this will\n   * produce a warning when called multiple times with different\n   * parameters.\n   *\n   * The returned promise resolves when loading completes\n   * and rejects in case of an error or when the loading was aborted.\n   */\n  static async load(params, onLoadingStatusChange) {\n    var _window$google;\n    const libraries = params.libraries ? params.libraries.split(',') : [];\n    const serializedParams = this.serializeParams(params);\n    // note: if google.maps.importLibrary was defined externally, the params\n    //   will be ignored. If it was defined by a previous call to this\n    //   method, we will check that the key and other parameters have not been\n    //   changed in between calls.\n    if (!((_window$google = window.google) != null && (_window$google = _window$google.maps) != null && _window$google.importLibrary)) {\n      this.serializedApiParams = serializedParams;\n      this.initImportLibrary(params, onLoadingStatusChange);\n    } else {\n      // if serializedApiParams isn't defined the library was loaded externally\n      // and we can only assume that went alright.\n      if (!this.serializedApiParams) {\n        this.loadingStatus = APILoadingStatus.LOADED;\n      }\n      onLoadingStatusChange(this.loadingStatus);\n    }\n    if (this.serializedApiParams && this.serializedApiParams !== serializedParams) {\n      console.warn(\"The maps API has already been loaded with different \" + \"parameters and will not be loaded again. Refresh the page for \" + \"new values to have effect.\");\n    }\n    for (const lib of ['maps', ...libraries]) {\n      await google.maps.importLibrary(lib);\n    }\n  }\n  static serializeParams(params) {\n    return [params.v, params.key, params.language, params.region, params.authReferrerPolicy, params.solutionChannel].join('/');\n  }\n  static initImportLibrary(params, onLoadingStatusChange) {\n    if (!window.google) window.google = {};\n    if (!window.google.maps) window.google.maps = {};\n    if (window.google.maps['importLibrary']) {\n      console.warn('initImportLibrary can only be called once.', params);\n      return;\n    }\n    let apiPromise = null;\n    const loadApi = library => {\n      if (apiPromise) return apiPromise;\n      apiPromise = new Promise((resolve, reject) => {\n        var _document$querySelect;\n        const scriptElement = document.createElement('script');\n        const urlParams = new URLSearchParams();\n        for (const [key, value] of Object.entries(params)) {\n          const urlParamName = key.replace(/[A-Z]/g, t => '_' + t[0].toLowerCase());\n          urlParams.set(urlParamName, value);\n        }\n        urlParams.set('libraries', library);\n        urlParams.set('callback', '__googleMapsCallback__');\n        scriptElement.src = MAPS_API_BASE_URL + \"?\" + urlParams.toString();\n        window.__googleMapsCallback__ = () => {\n          this.loadingStatus = APILoadingStatus.LOADED;\n          onLoadingStatusChange(this.loadingStatus);\n          resolve();\n        };\n        window.gm_authFailure = () => {\n          this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n          onLoadingStatusChange(this.loadingStatus);\n        };\n        scriptElement.onerror = () => {\n          this.loadingStatus = APILoadingStatus.FAILED;\n          onLoadingStatusChange(this.loadingStatus);\n          reject(new Error('The Google Maps JavaScript API could not load.'));\n        };\n        scriptElement.nonce = ((_document$querySelect = document.querySelector('script[nonce]')) == null ? void 0 : _document$querySelect.nonce) || '';\n        this.loadingStatus = APILoadingStatus.LOADING;\n        onLoadingStatusChange(this.loadingStatus);\n        document.head.append(scriptElement);\n      });\n      return apiPromise;\n    };\n    // for the first load, we declare an importLibrary function that will\n    // be overwritten once the api is loaded.\n    google.maps.importLibrary = libraryName => loadApi(libraryName).then(() => google.maps.importLibrary(libraryName));\n  }\n}\nGoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\nGoogleMapsApiLoader.serializedApiParams = void 0;\nconst _excluded$4 = [\"onLoad\", \"apiKey\", \"libraries\"],\n  _excluded2$1 = [\"children\"];\nconst APIProviderContext = React.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */\nfunction useMapInstances() {\n  const [mapInstances, setMapInstances] = useState({});\n  const addMapInstance = function (mapInstance) {\n    let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n    setMapInstances(instances => _extends({}, instances, {\n      [id]: mapInstance\n    }));\n  };\n  const removeMapInstance = function () {\n    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setMapInstances(_ref => {\n      let remaining = _objectWithoutPropertiesLoose(_ref, [id].map(_toPropertyKey));\n      return remaining;\n    });\n  };\n  const clearMapInstances = () => {\n    setMapInstances({});\n  };\n  return {\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances\n  };\n}\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */\nfunction useGoogleMapsApiLoader(props) {\n  const {\n      onLoad,\n      apiKey,\n      libraries = []\n    } = props,\n    otherApiParams = _objectWithoutPropertiesLoose(props, _excluded$4);\n  const [status, setStatus] = useState(GoogleMapsApiLoader.loadingStatus);\n  const [loadedLibraries, addLoadedLibrary] = useReducer((loadedLibraries, action) => {\n    return _extends({}, loadedLibraries, {\n      [action.name]: action.value\n    });\n  }, {});\n  const librariesString = useMemo(() => libraries == null ? void 0 : libraries.join(','), [libraries]);\n  const serializedParams = useMemo(() => JSON.stringify(otherApiParams), [otherApiParams]);\n  const importLibrary = useCallback(async name => {\n    var _google;\n    if (loadedLibraries[name]) {\n      return loadedLibraries[name];\n    }\n    if (!((_google = google) != null && (_google = _google.maps) != null && _google.importLibrary)) {\n      throw new Error('[api-provider-internal] importLibrary was called before ' + 'google.maps.importLibrary was defined.');\n    }\n    const res = await window.google.maps.importLibrary(name);\n    addLoadedLibrary({\n      name,\n      value: res\n    });\n    return res;\n  }, [loadedLibraries]);\n  useEffect(() => {\n    (async () => {\n      try {\n        await GoogleMapsApiLoader.load(_extends({\n          key: apiKey,\n          libraries: librariesString\n        }, otherApiParams), status => setStatus(status));\n        for (const name of ['core', 'maps', ...libraries]) {\n          await importLibrary(name);\n        }\n        if (onLoad) {\n          onLoad();\n        }\n      } catch (error) {\n        console.error('<ApiProvider> failed to load Google Maps API', error);\n      }\n    })();\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [apiKey, librariesString, serializedParams]);\n  return {\n    status,\n    loadedLibraries,\n    importLibrary\n  };\n}\n/**\n * Component to wrap the Google Maps React components and load the Google Maps JavaScript API\n */\nconst APIProvider = props => {\n  const {\n      children\n    } = props,\n    loaderProps = _objectWithoutPropertiesLoose(props, _excluded2$1);\n  const {\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances\n  } = useMapInstances();\n  const {\n    status,\n    loadedLibraries,\n    importLibrary\n  } = useGoogleMapsApiLoader(loaderProps);\n  return /*#__PURE__*/React.createElement(APIProviderContext.Provider, {\n    value: {\n      mapInstances,\n      addMapInstance,\n      removeMapInstance,\n      clearMapInstances,\n      status,\n      loadedLibraries,\n      importLibrary\n    }\n  }, children);\n};\nfunction useApiLoadingStatus() {\n  var _useContext;\n  return ((_useContext = useContext(APIProviderContext)) == null ? void 0 : _useContext.status) || APILoadingStatus.NOT_LOADED;\n}\n\n/**\n * Hook to check if the Google Maps API is loaded\n */\nfunction useApiIsLoaded() {\n  const status = useApiLoadingStatus();\n  return status === APILoadingStatus.LOADED;\n}\nconst shownMessages = new Set();\nfunction logErrorOnce() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  const key = JSON.stringify(args);\n  if (!shownMessages.has(key)) {\n    shownMessages.add(key);\n    console.error(...args);\n  }\n}\nfunction useCallbackRef() {\n  const [el, setEl] = useState(null);\n  const ref = useCallback(value => setEl(value), [setEl]);\n  return [el, ref];\n}\n\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is updated by `trackDispatchedEvent` and used in `useMapOptions`.\n */\nfunction useInternalCameraState() {\n  return useRef({\n    center: {\n      lat: 0,\n      lng: 0\n    },\n    heading: 0,\n    tilt: 0,\n    zoom: 0\n  });\n}\n/**\n * Records camera data from the last event dispatched to the React application\n * in a mutable `IternalCameraStateRef`.\n * This data can then be used to prevent feeding these values back to the\n * map-instance when a typical \"controlled component\" setup (state variable is\n * fed into and updated by the map).\n */\nfunction trackDispatchedEvent(ev, cameraStateRef) {\n  const cameraEvent = ev;\n  // we're only interested in the camera-events here\n  if (!cameraEvent.detail.center) return;\n  const {\n    center,\n    zoom,\n    heading,\n    tilt\n  } = cameraEvent.detail;\n  cameraStateRef.current.center = center;\n  cameraStateRef.current.heading = heading;\n  cameraStateRef.current.tilt = tilt;\n  cameraStateRef.current.zoom = zoom;\n}\n\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */\nfunction useMapEvents(map, cameraStateRef, props) {\n  // note: calling a useEffect hook from within a loop is prohibited by the\n  // rules of hooks, but it's ok here since it's unconditional and the number\n  // and order of iterations is always strictly the same.\n  // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n  for (const propName of eventPropNames) {\n    // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n    //   a proper solution seems way too complicated right now\n    const handler = props[propName];\n    const eventType = propNameToEventType[propName];\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!map) return;\n      if (!handler) return;\n      const listener = google.maps.event.addListener(map, eventType, ev => {\n        const mapEvent = createMapEvent(eventType, map, ev);\n        trackDispatchedEvent(mapEvent, cameraStateRef);\n        handler(mapEvent);\n      });\n      return () => listener.remove();\n    }, [map, cameraStateRef, eventType, handler]);\n  }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */\nfunction createMapEvent(type, map, srcEvent) {\n  const ev = {\n    type,\n    map,\n    detail: {},\n    stoppable: false,\n    stop: () => {}\n  };\n  if (cameraEventTypes.includes(type)) {\n    const camEvent = ev;\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n      console.warn('[createEvent] at least one of the values from the map ' + 'returned undefined. This is not expected to happen. Please ' + 'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n    }\n    camEvent.detail = {\n      center: (center == null ? void 0 : center.toJSON()) || {\n        lat: 0,\n        lng: 0\n      },\n      zoom: zoom,\n      heading: heading,\n      tilt: tilt,\n      bounds: (bounds == null ? void 0 : bounds.toJSON()) || {\n        north: 90,\n        east: 180,\n        south: -90,\n        west: -180\n      }\n    };\n    return camEvent;\n  } else if (mouseEventTypes.includes(type)) {\n    var _srcEvent$latLng;\n    if (!srcEvent) throw new Error('[createEvent] mouse events must provide a srcEvent');\n    const mouseEvent = ev;\n    mouseEvent.domEvent = srcEvent.domEvent;\n    mouseEvent.stoppable = true;\n    mouseEvent.stop = () => srcEvent.stop();\n    mouseEvent.detail = {\n      latLng: ((_srcEvent$latLng = srcEvent.latLng) == null ? void 0 : _srcEvent$latLng.toJSON()) || null,\n      placeId: srcEvent.placeId\n    };\n    return mouseEvent;\n  }\n  return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */\nconst propNameToEventType = {\n  onBoundsChanged: 'bounds_changed',\n  onCenterChanged: 'center_changed',\n  onClick: 'click',\n  onContextmenu: 'contextmenu',\n  onDblclick: 'dblclick',\n  onDrag: 'drag',\n  onDragend: 'dragend',\n  onDragstart: 'dragstart',\n  onHeadingChanged: 'heading_changed',\n  onIdle: 'idle',\n  onIsFractionalZoomEnabledChanged: 'isfractionalzoomenabled_changed',\n  onMapCapabilitiesChanged: 'mapcapabilities_changed',\n  onMapTypeIdChanged: 'maptypeid_changed',\n  onMousemove: 'mousemove',\n  onMouseout: 'mouseout',\n  onMouseover: 'mouseover',\n  onProjectionChanged: 'projection_changed',\n  onRenderingTypeChanged: 'renderingtype_changed',\n  onTilesLoaded: 'tilesloaded',\n  onTiltChanged: 'tilt_changed',\n  onZoomChanged: 'zoom_changed'\n};\nconst cameraEventTypes = ['bounds_changed', 'center_changed', 'heading_changed', 'projection_changed', 'tilt_changed', 'zoom_changed'];\nconst mouseEventTypes = ['click', 'contextmenu', 'dblclick', 'mousemove', 'mouseout', 'mouseover'];\nconst eventPropNames = Object.keys(propNameToEventType);\nfunction isLatLngLiteral(obj) {\n  if (!obj || typeof obj !== 'object') return false;\n  if (!('lat' in obj && 'lng' in obj)) return false;\n  return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nconst _excluded$3 = [\"center\", \"zoom\", \"heading\", \"tilt\"],\n  _excluded2 = [\"mapId\"];\n/**\n * Internal hook to update the map-options and camera parameters when\n * props are changed.\n *\n * @param map the map instance\n * @param cameraStateRef stores the last values seen during dispatch into the\n * react-application in useMapEvents(). We can safely assume that we\n * don't need to feed these values back into the map.\n * @param mapProps the props to update the map-instance with\n * @internal\n */\nfunction useMapOptions(map, cameraStateRef, mapProps) {\n  const {\n      center: rawCenter,\n      zoom,\n      heading,\n      tilt\n    } = mapProps,\n    mapOptions = _objectWithoutPropertiesLoose(mapProps, _excluded$3);\n  const center = rawCenter ? isLatLngLiteral(rawCenter) ? rawCenter : rawCenter.toJSON() : null;\n  const lat = center && center.lat;\n  const lng = center && center.lng;\n  /* eslint-disable react-hooks/exhaustive-deps --\n   *\n   * The following effects aren't triggered when the map is changed.\n   * In that case, the values will be or have been passed to the map\n   * constructor as mapOptions.\n   */\n  // update the map options when mapOptions is changed\n  // Note: due to the destructuring above, mapOptions will be seen as changed\n  //   with every re-render, so we're boldly assuming the maps-api will properly\n  //   deal with unchanged option-values passed into setOptions.\n  useEffect(() => {\n    if (!map) return;\n    // Changing the mapId via setOptions will trigger an error-message.\n    // We will re-create the map-instance in that case anyway, so we\n    // remove it here to avoid this error-message.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const opts = _objectWithoutPropertiesLoose(mapOptions, _excluded2);\n    map.setOptions(opts);\n  }, [mapOptions]);\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(lat) || !Number.isFinite(lng)) return;\n    if (cameraStateRef.current.center.lat === lat && cameraStateRef.current.center.lng === lng) return;\n    map.moveCamera({\n      center: {\n        lat: lat,\n        lng: lng\n      }\n    });\n  }, [lat, lng]);\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(zoom)) return;\n    if (cameraStateRef.current.zoom === zoom) return;\n    map.moveCamera({\n      zoom: zoom\n    });\n  }, [zoom]);\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(heading)) return;\n    if (cameraStateRef.current.heading === heading) return;\n    map.moveCamera({\n      heading: heading\n    });\n  }, [heading]);\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(tilt)) return;\n    if (cameraStateRef.current.tilt === tilt) return;\n    map.moveCamera({\n      tilt: tilt\n    });\n  }, [tilt]);\n  /* eslint-enable react-hooks/exhaustive-deps */\n}\n\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */\nfunction useDeckGLCameraUpdate(map, viewState) {\n  useLayoutEffect(() => {\n    if (!map || !viewState) {\n      return;\n    }\n    // FIXME: this should probably be extracted into a seperate hook that only\n    //  runs once when first seeing a deck.gl viewState update and resets\n    //  again. Maybe even use a seperate prop (`<Map controlled />`) instead.\n    map.setOptions({\n      gestureHandling: 'none',\n      keyboardShortcuts: false,\n      disableDefaultUI: true\n    });\n    const {\n      latitude,\n      longitude,\n      bearing: heading,\n      pitch: tilt,\n      zoom\n    } = viewState;\n    map.moveCamera({\n      center: {\n        lat: latitude,\n        lng: longitude\n      },\n      heading,\n      tilt,\n      zoom: zoom + 1\n    });\n  }, [map, viewState]);\n}\nconst _excluded$2 = [\"id\", \"initialBounds\"];\nconst GoogleMapsContext = React.createContext(null);\n/**\n * Component to render a Google Maps map\n */\nconst Map = props => {\n  const {\n    children,\n    id,\n    className,\n    style,\n    viewState,\n    viewport\n  } = props;\n  const context = useContext(APIProviderContext);\n  const loadingStatus = useApiLoadingStatus();\n  if (!context) {\n    throw new Error('<Map> can only be used inside an <ApiProvider> component.');\n  }\n  const [map, mapRef] = useMapInstance(props, context);\n  const cameraStateRef = useInternalCameraState();\n  useMapOptions(map, cameraStateRef, props);\n  useMapEvents(map, cameraStateRef, props);\n  useDeckGLCameraUpdate(map, viewState);\n  const isViewportSet = useMemo(() => Boolean(viewport), [viewport]);\n  const combinedStyle = useMemo(() => _extends({\n    width: '100%',\n    height: '100%',\n    // when using deckgl, the map should be sent to the back\n    zIndex: isViewportSet ? -1 : 0\n  }, style), [style, isViewportSet]);\n  if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      style: _extends({\n        position: 'relative'\n      }, className ? {} : combinedStyle),\n      className: className\n    }, /*#__PURE__*/React.createElement(AuthFailureMessage, null));\n  }\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: mapRef,\n    \"data-testid\": 'map',\n    style: className ? undefined : combinedStyle,\n    className: className\n  }, id ? {\n    id\n  } : {}), map ? /*#__PURE__*/React.createElement(GoogleMapsContext.Provider, {\n    value: {\n      map\n    }\n  }, children) : null);\n};\nMap.deckGLViewProps = true;\nconst AuthFailureMessage = () => {\n  const style = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    zIndex: 999,\n    display: 'flex',\n    flexFlow: 'column nowrap',\n    textAlign: 'center',\n    justifyContent: 'center',\n    fontSize: '.8rem',\n    color: 'rgba(0,0,0,0.6)',\n    background: '#dddddd',\n    padding: '1rem 1.5rem'\n  };\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: style\n  }, /*#__PURE__*/React.createElement(\"h2\", null, \"Error: AuthFailure\"), /*#__PURE__*/React.createElement(\"p\", null, \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \", /*#__PURE__*/React.createElement(\"code\", null, \"APIProvider.apiKey\"), \" prop is correct. Check the error-message in the console for further details.\"));\n};\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */\nfunction useMapInstance(props, context) {\n  const apiIsLoaded = useApiIsLoaded();\n  const [map, setMap] = useState(null);\n  const [container, containerRef] = useCallbackRef();\n  const {\n      id,\n      initialBounds\n    } = props,\n    mapOptions = _objectWithoutPropertiesLoose(props, _excluded$2);\n  // create the map instance and register it in the context\n  useEffect(() => {\n    if (!container || !apiIsLoaded) return;\n    const {\n      addMapInstance,\n      removeMapInstance\n    } = context;\n    const newMap = new google.maps.Map(container, mapOptions);\n    setMap(newMap);\n    addMapInstance(newMap, id);\n    if (initialBounds) {\n      newMap.fitBounds(initialBounds);\n    }\n    return () => {\n      if (!container || !apiIsLoaded) return;\n      // remove all event-listeners to minimize memory-leaks\n      google.maps.event.clearInstanceListeners(newMap);\n      setMap(null);\n      removeMapInstance(id);\n    };\n  },\n  // FIXME: we should rethink if it could be possible to keep the state\n  //   around when a map gets re-initialized (id or mapId changed). This\n  //   should keep the viewport as it is (so also no initial viewport in\n  //   this case) and any added features should of course get re-added as\n  //   well.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [id, container, apiIsLoaded, props.mapId]);\n  // report an error if the same map-id is used multiple times\n  useEffect(() => {\n    if (!id) return;\n    const {\n      mapInstances\n    } = context;\n    if (mapInstances[id] && mapInstances[id] !== map) {\n      logErrorOnce(\"The map id '\".concat(id, \"' seems to have been used multiple times. \") + 'This can lead to unexpected problems when accessing the maps. ' + 'Please use unique ids for all <Map> components.');\n    }\n  }, [id, context, map]);\n  return [map, containerRef];\n}\nfunction useMapsLibrary(name) {\n  const apiIsLoaded = useApiIsLoaded();\n  const ctx = useContext(APIProviderContext);\n  useEffect(() => {\n    if (!apiIsLoaded || !ctx) return;\n    // Trigger loading the libraries via our proxy-method.\n    // The returned promise is ignored, since importLibrary will update loadedLibraries\n    // list in the context, triggering a re-render.\n    void ctx.importLibrary(name);\n  }, [apiIsLoaded, ctx == null ? void 0 : ctx.importLibrary]);\n  return (ctx == null ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n\n/* eslint-disable complexity */\nconst AdvancedMarkerContext = React.createContext(null);\nfunction useAdvancedMarker(props) {\n  var _useContext;\n  const [marker, setMarker] = useState(null);\n  const [contentContainer, setContentContainer] = useState(null);\n  const map = (_useContext = useContext(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n  const markerLibrary = useMapsLibrary('marker');\n  const {\n    children,\n    className,\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    collisionBehavior,\n    draggable,\n    position,\n    title,\n    zIndex\n  } = props;\n  const numChilds = Children.count(children);\n  // create marker instance and add it to the map when map becomes available\n  useEffect(() => {\n    if (!map || !markerLibrary) return;\n    const newMarker = new markerLibrary.AdvancedMarkerElement();\n    newMarker.map = map;\n    setMarker(newMarker);\n    // create container for marker content if there are children\n    if (numChilds > 0) {\n      const el = document.createElement('div');\n      if (className) el.className = className;\n      newMarker.content = el;\n      setContentContainer(el);\n    }\n    return () => {\n      newMarker.map = null;\n      setMarker(null);\n      setContentContainer(null);\n    };\n  }, [map, markerLibrary, numChilds]);\n  // bind all marker events\n  useEffect(() => {\n    if (!marker) return;\n    const gme = google.maps.event;\n    if (onClick) gme.addListener(marker, 'click', onClick);\n    if (onDrag) gme.addListener(marker, 'drag', onDrag);\n    if (onDragStart) gme.addListener(marker, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(marker, 'dragend', onDragEnd);\n    if ((onDrag || onDragStart || onDragEnd) && !draggable) {\n      console.warn('You need to set the marker to draggable to listen to drag-events.');\n    }\n    const m = marker;\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [marker, draggable, onClick, onDragStart, onDrag, onDragEnd]);\n  // update other marker props when changed\n  useEffect(() => {\n    if (!marker) return;\n    if (position !== undefined) marker.position = position;\n    if (draggable !== undefined) marker.gmpDraggable = draggable;\n    if (collisionBehavior !== undefined) marker.collisionBehavior = collisionBehavior;\n    if (zIndex !== undefined) marker.zIndex = zIndex;\n    if (typeof title === 'string') marker.title = title;\n  }, [marker, position, draggable, collisionBehavior, zIndex, title]);\n  return [marker, contentContainer];\n}\nconst AdvancedMarker = forwardRef((props, ref) => {\n  const {\n    children\n  } = props;\n  const [marker, contentContainer] = useAdvancedMarker(props);\n  useImperativeHandle(ref, () => marker, [marker]);\n  if (!marker) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(AdvancedMarkerContext.Provider, {\n    value: {\n      marker\n    }\n  }, contentContainer !== null && createPortal(children, contentContainer));\n});\nfunction useAdvancedMarkerRef() {\n  const [marker, setMarker] = useState(null);\n  const refCallback = useCallback(m => {\n    setMarker(m);\n  }, []);\n  return [refCallback, marker];\n}\nconst _excluded$1 = [\"children\", \"anchor\", \"onCloseClick\"];\n/**\n * Component to render a Google Maps Info Window\n */\nconst InfoWindow = props => {\n  var _useContext;\n  const {\n      children,\n      anchor,\n      onCloseClick\n    } = props,\n    infoWindowOptions = _objectWithoutPropertiesLoose(props, _excluded$1);\n  const map = (_useContext = useContext(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n  const [contentContainer, setContentContainer] = useState(null);\n  // create infowindow once map is available\n  useEffect(() => {\n    if (!map) return;\n    const infoWindow = new google.maps.InfoWindow(infoWindowOptions);\n    // Add content to info window\n    const el = document.createElement('div');\n    infoWindow.setContent(el);\n    infoWindow.open({\n      map,\n      anchor\n    });\n    if (onCloseClick) {\n      google.maps.event.addListener(infoWindow, 'closeclick', () => {\n        onCloseClick();\n      });\n    }\n    setContentContainer(el);\n    // Cleanup info window and event listeners on unmount\n    return () => {\n      google.maps.event.clearInstanceListeners(infoWindow);\n      infoWindow.close();\n      el.remove();\n      setContentContainer(null);\n    };\n  }, [map, children, anchor]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentContainer !== null && createPortal(children, contentContainer));\n};\n\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */\nconst useMap = function () {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  const ctx = useContext(APIProviderContext);\n  const {\n    map\n  } = useContext(GoogleMapsContext) || {};\n  if (ctx === null) {\n    logErrorOnce('useMap(): failed to retrieve APIProviderContext. ' + 'Make sure that the <APIProvider> component exists and that the ' + 'component you are calling `useMap()` from is a sibling of the ' + '<APIProvider>.');\n    return null;\n  }\n  const {\n    mapInstances\n  } = ctx;\n  // if an id is specified, the corresponding map or null is returned\n  if (id !== null) return mapInstances[id] || null;\n  // otherwise, return the closest ancestor\n  if (map) return map;\n  // finally, return the default map instance\n  return mapInstances['default'] || null;\n};\n\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nconst ControlPosition = {\n  TOP_LEFT: 1,\n  TOP_CENTER: 2,\n  TOP: 2,\n  TOP_RIGHT: 3,\n  LEFT_CENTER: 4,\n  LEFT_TOP: 5,\n  LEFT: 5,\n  LEFT_BOTTOM: 6,\n  RIGHT_TOP: 7,\n  RIGHT: 7,\n  RIGHT_CENTER: 8,\n  RIGHT_BOTTOM: 9,\n  BOTTOM_LEFT: 10,\n  BOTTOM_CENTER: 11,\n  BOTTOM: 11,\n  BOTTOM_RIGHT: 12,\n  CENTER: 13,\n  BLOCK_START_INLINE_START: 14,\n  BLOCK_START_INLINE_CENTER: 15,\n  BLOCK_START_INLINE_END: 16,\n  INLINE_START_BLOCK_CENTER: 17,\n  INLINE_START_BLOCK_START: 18,\n  INLINE_START_BLOCK_END: 19,\n  INLINE_END_BLOCK_START: 20,\n  INLINE_END_BLOCK_CENTER: 21,\n  INLINE_END_BLOCK_END: 22,\n  BLOCK_END_INLINE_START: 23,\n  BLOCK_END_INLINE_CENTER: 24,\n  BLOCK_END_INLINE_END: 25\n};\nconst MapControl = _ref2 => {\n  let {\n    children,\n    position\n  } = _ref2;\n  const controlContainer = useMemo(() => document.createElement('div'), []);\n  const map = useMap();\n  useEffect(() => {\n    if (!map) return;\n    const controls = map.controls[position];\n    controls.push(controlContainer);\n    return () => {\n      const index = controls.getArray().indexOf(controlContainer);\n      controls.removeAt(index);\n    };\n  }, [map, position]);\n  return createPortal(children, controlContainer);\n};\nconst _excluded = [\"onClick\", \"onDrag\", \"onDragStart\", \"onDragEnd\", \"onMouseOver\", \"onMouseOut\"];\nfunction useMarker(props) {\n  var _useContext;\n  const [marker, setMarker] = useState(null);\n  const map = (_useContext = useContext(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n  const {\n      onClick,\n      onDrag,\n      onDragStart,\n      onDragEnd,\n      onMouseOver,\n      onMouseOut\n    } = props,\n    markerOptions = _objectWithoutPropertiesLoose(props, _excluded);\n  const {\n    position,\n    draggable\n  } = markerOptions;\n  // create marker instance and add to the map once the map is available\n  useEffect(() => {\n    if (!map) {\n      if (map === undefined) console.error('<Marker> has to be inside a Map component.');\n      return;\n    }\n    const newMarker = new google.maps.Marker(markerOptions);\n    newMarker.setMap(map);\n    setMarker(newMarker);\n    return () => {\n      newMarker.setMap(null);\n      setMarker(null);\n    };\n  }, [map]);\n  // attach and re-attach event-handlers when any of the properties change\n  useEffect(() => {\n    if (!marker) return;\n    const m = marker;\n    // Add event listeners\n    const gme = google.maps.event;\n    if (onClick) gme.addListener(m, 'click', onClick);\n    if (onDrag) gme.addListener(m, 'drag', onDrag);\n    if (onDragStart) gme.addListener(m, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(m, 'dragend', onDragEnd);\n    if (onMouseOver) gme.addListener(m, 'mouseover', onMouseOver);\n    if (onMouseOut) gme.addListener(m, 'mouseout', onMouseOut);\n    marker.setDraggable(Boolean(draggable));\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [marker, draggable, onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut]);\n  // update markerOptions (note the dependencies aren't properly checked\n  // here, we just assume that setOptions is smart enough to not waste a\n  // lot of time updating values that didn't change)\n  useEffect(() => {\n    if (!marker) return;\n    if (markerOptions) marker.setOptions(markerOptions);\n  }, [marker, markerOptions]);\n  // update position when changed\n  useEffect(() => {\n    // Should not update position when draggable\n    if (draggable || !position || !marker) return;\n    marker.setPosition(position);\n  }, [draggable, position, marker]);\n  return marker;\n}\n/**\n * Component to render a Google Maps Marker on a map\n */\nconst Marker = forwardRef((props, ref) => {\n  const marker = useMarker(props);\n  useImperativeHandle(ref, () => marker, [marker]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null);\n});\nfunction useMarkerRef() {\n  const [marker, setMarker] = useState(null);\n  const refCallback = useCallback(m => {\n    setMarker(m);\n  }, []);\n  return [refCallback, marker];\n}\n\n/**\n * Component to render a google maps marker Pin View\n */\nconst Pin = props => {\n  var _useContext;\n  const advancedMarker = (_useContext = useContext(AdvancedMarkerContext)) == null ? void 0 : _useContext.marker;\n  const glyphContainer = useMemo(() => document.createElement('div'), []);\n  // Create Pin View instance\n  useEffect(() => {\n    if (!advancedMarker) {\n      if (advancedMarker === undefined) {\n        console.error('The <Pin> component can only be used inside <AdvancedMarker>.');\n      }\n      return;\n    }\n    if (props.glyph && props.children) {\n      logErrorOnce('The <Pin> component only uses children to render the glyph if both the glyph property and children are present.');\n    }\n    if (Children.count(props.children) > 1) {\n      logErrorOnce('Passing multiple children to the <Pin> component might lead to unexpected results.');\n    }\n    const pinViewOptions = _extends({}, props);\n    const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n    // Set glyph to glyph container if children are present (rendered via portal).\n    // If both props.glyph and props.children are present, props.children takes priority.\n    if (props.children) {\n      pinElement.glyph = glyphContainer;\n    }\n    // Set content of Advanced Marker View to the Pin View element\n    advancedMarker.content = pinElement.element;\n  }, [advancedMarker, props]);\n  return createPortal(props.children, glyphContainer);\n};\n\n/**\n * Hook to get a Google Maps Places Autocomplete instance\n * monitoring an input field\n */\nconst useAutocomplete = props => {\n  const {\n    inputField,\n    options,\n    onPlaceChanged\n  } = props;\n  const googleMapsAPIIsLoaded = useApiIsLoaded();\n  const placeChangedHandler = useRef(onPlaceChanged);\n  const [autocomplete, setAutocomplete] = useState(null);\n  // Initializes the Google Maps Places Autocomplete\n  useEffect(() => {\n    // Wait for the Google Maps API and input element to be initialized\n    if (!googleMapsAPIIsLoaded || !inputField) return;\n    // FIXME: add dynamic loading for required libraries\n    if (!google.maps.places) {\n      console.error('Google Maps Places library is missing. ' + 'Please add the places library to the props of the <ApiProvider> ' + 'component.');\n      return;\n    }\n    // Create Autocomplete instance\n    const autocompleteInstance = new google.maps.places.Autocomplete(inputField, options);\n    setAutocomplete(autocompleteInstance);\n    // Add places change listener to Autocomplete\n    autocompleteInstance.addListener('place_changed', () => {\n      const place = autocompleteInstance.getPlace();\n      if (placeChangedHandler.current) placeChangedHandler.current(place);\n    });\n    // Clear listeners on unmount\n    return () => {\n      if (autocompleteInstance && typeof google.maps === 'object') {\n        google.maps.event.clearInstanceListeners(autocompleteInstance);\n      }\n    };\n  }, [googleMapsAPIIsLoaded, inputField, options]);\n  return autocomplete;\n};\n\n/**\n * A typescript assertion function used in cases where typescript has to be\n * convinced that the object in question can not be null.\n *\n * @param value\n * @param message\n */\nfunction assertNotNull(value) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'assertion failed';\n  if (value === null || value === undefined) {\n    throw Error(message);\n  }\n}\nconst useDirectionsRenderer = (mapId, renderOnMap, renderOptions) => {\n  const map = useMap(mapId);\n  // create the renderer instance\n  const directionsRenderer = useMemo(() => {\n    if (!map || !renderOnMap) return null;\n    const renderer = new google.maps.DirectionsRenderer(renderOptions);\n    renderer.setMap(map);\n    return renderer;\n  },\n  // note: no dependency on renderOptions since those are handled in the\n  // next effect.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [map, renderOnMap]);\n  useEffect(() => {\n    if (!directionsRenderer) return;\n    directionsRenderer.setOptions(renderOptions || {});\n  },\n  // note: directionsRenderer dependency isn't needed since the\n  // renderOptions will be set on initialization when creating the renderer.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [renderOptions]);\n  return directionsRenderer;\n};\n/**\n * Hook to get Google Maps Places Directions Service instance\n */\nconst useDirectionsService = function () {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    mapId = null,\n    renderOnMap,\n    renderOptions\n  } = props;\n  const isApiLoaded = useApiIsLoaded();\n  // Creates a Directions Service instance\n  const directionsService = useMemo(() => {\n    // Wait for Google Maps API to be loaded\n    if (!isApiLoaded) return null;\n    return new google.maps.DirectionsService();\n  }, [isApiLoaded]);\n  // create the renderer instance\n  const directionsRenderer = useDirectionsRenderer(mapId, renderOnMap, renderOptions);\n  // Custom Directions route request followed by directions rendering\n  const renderRoute = useCallback(async request => {\n    // findAndRenderRoute() isn't callable when either directions\n    // service or renderer aren't ready\n    assertNotNull(directionsService);\n    assertNotNull(directionsRenderer);\n    const result = await directionsService.route(request);\n    directionsRenderer.setDirections(result);\n    return result;\n  }, [directionsService, directionsRenderer]);\n  // Renders directions route of given index\n  const setRenderedRouteIndex = index => {\n    assertNotNull(directionsRenderer);\n    directionsRenderer.setRouteIndex(index);\n  };\n  return {\n    directionsService,\n    directionsRenderer,\n    renderRoute: directionsService && directionsRenderer ? renderRoute : null,\n    setRenderedRouteIndex: directionsService && directionsRenderer ? setRenderedRouteIndex : null\n  };\n};\n\n/* eslint-disable complexity */\n/**\n * Hook to get Street View Panorama\n */\nconst useStreetViewPanorama = function () {\n  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    mapId,\n    divElement,\n    position,\n    pov,\n    zoom\n  } = props;\n  const googleMapsAPIIsLoaded = useApiIsLoaded();\n  const map = useMap(mapId);\n  const [streetViewPanorama, setStreetViewPanorama] = useState(null);\n  // Creates a Street View instance\n  useEffect(() => {\n    if (!googleMapsAPIIsLoaded) return;\n    let pano = null;\n    if (divElement) {\n      pano = new google.maps.StreetViewPanorama(divElement);\n    } else if (map) {\n      pano = map.getStreetView();\n    }\n    setStreetViewPanorama(pano);\n    if (!pano) return;\n    if (pov) pano.setPov(pov);\n    if (position) pano.setPosition(position);\n    if (zoom || zoom === 0) pano.setZoom(zoom);\n    return () => {\n      setStreetViewPanorama(null);\n      if (map) map.setStreetView(null);\n    };\n  },\n  // fixme: implement extra hook to update FOV when props change\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [googleMapsAPIIsLoaded, map, divElement]);\n  return streetViewPanorama;\n};\nconst mapLinear = (x, a1, a2, b1, b2) => b1 + (x - a1) * (b2 - b1) / (a2 - a1);\nconst getMapMaxTilt = zoom => {\n  if (zoom <= 10) {\n    return 30;\n  }\n  if (zoom >= 15.5) {\n    return 67.5;\n  }\n  // range [10...14]\n  if (zoom <= 14) {\n    return mapLinear(zoom, 10, 14, 30, 45);\n  }\n  // range [14...15.5]\n  return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the google maps map when updating the view state\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = _ref3 => {\n  let {\n    viewState\n  } = _ref3;\n  const pitch = viewState.pitch;\n  const gmZoom = viewState.zoom + 1;\n  const maxTilt = getMapMaxTilt(gmZoom);\n  return _extends({}, viewState, {\n    fovy: 25,\n    pitch: Math.min(maxTilt, pitch)\n  });\n};\nexport { APIProvider, APIProviderContext, AdvancedMarker, AdvancedMarkerContext, ControlPosition, GoogleMapsContext, InfoWindow, Map, MapControl, Marker, Pin, limitTiltRange, useAdvancedMarkerRef, useApiIsLoaded, useApiLoadingStatus, useAutocomplete, useDirectionsService, useMap, useMapsLibrary, useMarkerRef, useStreetViewPanorama };","map":{"version":3,"names":["APILoadingStatus","NOT_LOADED","LOADING","LOADED","FAILED","AUTH_FAILURE","MAPS_API_BASE_URL","GoogleMapsApiLoader","load","params","onLoadingStatusChange","_window$google","libraries","split","serializedParams","serializeParams","window","google","maps","importLibrary","serializedApiParams","initImportLibrary","loadingStatus","console","warn","lib","v","key","language","region","authReferrerPolicy","solutionChannel","join","apiPromise","loadApi","library","Promise","resolve","reject","_document$querySelect","scriptElement","document","createElement","urlParams","URLSearchParams","value","Object","entries","urlParamName","replace","t","toLowerCase","set","src","toString","__googleMapsCallback__","gm_authFailure","onerror","Error","nonce","querySelector","head","append","libraryName","then","APIProviderContext","React","createContext","useMapInstances","mapInstances","setMapInstances","useState","addMapInstance","mapInstance","id","arguments","length","undefined","instances","_extends","removeMapInstance","_ref","remaining","_objectWithoutPropertiesLoose","map","_toPropertyKey","clearMapInstances","useGoogleMapsApiLoader","props","onLoad","apiKey","otherApiParams","_excluded$4","status","setStatus","loadedLibraries","addLoadedLibrary","useReducer","action","name","librariesString","useMemo","JSON","stringify","useCallback","_google","res","useEffect","error","APIProvider","children","loaderProps","_excluded2$1","Provider","useApiLoadingStatus","_useContext","useContext","useApiIsLoaded","shownMessages","Set","logErrorOnce","_len","args","Array","_key","has","add","useCallbackRef","el","setEl","ref","useInternalCameraState","useRef","center","lat","lng","heading","tilt","zoom","trackDispatchedEvent","ev","cameraStateRef","cameraEvent","detail","current","useMapEvents","propName","eventPropNames","handler","eventType","propNameToEventType","listener","event","addListener","mapEvent","createMapEvent","remove","type","srcEvent","stoppable","stop","cameraEventTypes","includes","camEvent","getCenter","getZoom","getHeading","getTilt","bounds","getBounds","Number","isFinite","toJSON","north","east","south","west","mouseEventTypes","_srcEvent$latLng","mouseEvent","domEvent","latLng","placeId","onBoundsChanged","onCenterChanged","onClick","onContextmenu","onDblclick","onDrag","onDragend","onDragstart","onHeadingChanged","onIdle","onIsFractionalZoomEnabledChanged","onMapCapabilitiesChanged","onMapTypeIdChanged","onMousemove","onMouseout","onMouseover","onProjectionChanged","onRenderingTypeChanged","onTilesLoaded","onTiltChanged","onZoomChanged","keys","isLatLngLiteral","obj","useMapOptions","mapProps","rawCenter","mapOptions","_excluded$3","opts","_excluded2","setOptions","useLayoutEffect","moveCamera","useDeckGLCameraUpdate","viewState","gestureHandling","keyboardShortcuts","disableDefaultUI","latitude","longitude","bearing","pitch","GoogleMapsContext","Map","className","style","viewport","context","mapRef","useMapInstance","isViewportSet","Boolean","combinedStyle","width","height","zIndex","position","AuthFailureMessage","deckGLViewProps","top","left","bottom","right","display","flexFlow","textAlign","justifyContent","fontSize","color","background","padding","apiIsLoaded","setMap","container","containerRef","initialBounds","_excluded$2","newMap","fitBounds","clearInstanceListeners","mapId","concat","useMapsLibrary","ctx","AdvancedMarkerContext","useAdvancedMarker","marker","setMarker","contentContainer","setContentContainer","markerLibrary","onDragStart","onDragEnd","collisionBehavior","draggable","title","numChilds","Children","count","newMarker","AdvancedMarkerElement","content","gme","m","gmpDraggable","AdvancedMarker","forwardRef","useImperativeHandle","createPortal","useAdvancedMarkerRef","refCallback","InfoWindow","anchor","onCloseClick","infoWindowOptions","_excluded$1","infoWindow","setContent","open","close","Fragment","useMap","ControlPosition","TOP_LEFT","TOP_CENTER","TOP","TOP_RIGHT","LEFT_CENTER","LEFT_TOP","LEFT","LEFT_BOTTOM","RIGHT_TOP","RIGHT","RIGHT_CENTER","RIGHT_BOTTOM","BOTTOM_LEFT","BOTTOM_CENTER","BOTTOM","BOTTOM_RIGHT","CENTER","BLOCK_START_INLINE_START","BLOCK_START_INLINE_CENTER","BLOCK_START_INLINE_END","INLINE_START_BLOCK_CENTER","INLINE_START_BLOCK_START","INLINE_START_BLOCK_END","INLINE_END_BLOCK_START","INLINE_END_BLOCK_CENTER","INLINE_END_BLOCK_END","BLOCK_END_INLINE_START","BLOCK_END_INLINE_CENTER","BLOCK_END_INLINE_END","MapControl","_ref2","controlContainer","controls","push","index","getArray","indexOf","removeAt","useMarker","onMouseOver","onMouseOut","markerOptions","_excluded","Marker","setDraggable","setPosition","useMarkerRef","Pin","advancedMarker","glyphContainer","glyph","pinViewOptions","pinElement","PinElement","element","useAutocomplete","inputField","options","onPlaceChanged","googleMapsAPIIsLoaded","placeChangedHandler","autocomplete","setAutocomplete","places","autocompleteInstance","Autocomplete","place","getPlace","assertNotNull","message","useDirectionsRenderer","renderOnMap","renderOptions","directionsRenderer","renderer","DirectionsRenderer","useDirectionsService","isApiLoaded","directionsService","DirectionsService","renderRoute","request","result","route","setDirections","setRenderedRouteIndex","setRouteIndex","useStreetViewPanorama","divElement","pov","streetViewPanorama","setStreetViewPanorama","pano","StreetViewPanorama","getStreetView","setPov","setZoom","setStreetView","mapLinear","x","a1","a2","b1","b2","getMapMaxTilt","limitTiltRange","_ref3","gmZoom","maxTilt","fovy","Math","min"],"sources":["C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\libraries\\api-loading-status.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\libraries\\google-maps-api-loader.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\api-provider.tsx","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\hooks\\use-api-loading-status.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\hooks\\use-api-is-loaded.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\libraries\\errors.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\libraries\\use-callback-ref.tsx","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\map\\use-internal-camera-state.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\map\\use-map-events.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\libraries\\is-lat-lng-literal.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\map\\use-map-options.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\map\\use-deckgl-camera-update.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\map\\index.tsx","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\hooks\\use-maps-library.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\advanced-marker.tsx","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\info-window.tsx","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\hooks\\use-map.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\map-control.tsx","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\marker.tsx","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\components\\pin.tsx","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\hooks\\autocomplete.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\libraries\\assert-not-null.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\hooks\\directions-service.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\hooks\\street-view-panorama.ts","C:\\Users\\ASUS\\Documents\\GitHub\\e19-3yp-School-Van-Tracking-System\\code\\webapplication\\node_modules\\@vis.gl\\react-google-maps\\src\\libraries\\limit-tilt-range.ts"],"sourcesContent":["export const APILoadingStatus = {\n  NOT_LOADED: 'NOT_LOADED',\n  LOADING: 'LOADING',\n  LOADED: 'LOADED',\n  FAILED: 'FAILED',\n  AUTH_FAILURE: 'AUTH_FAILURE'\n};\nexport type APILoadingStatus =\n  (typeof APILoadingStatus)[keyof typeof APILoadingStatus];\n","import {APILoadingStatus} from './api-loading-status';\n\nexport type ApiParams = {\n  key: string;\n  v?: string;\n  language?: string;\n  region?: string;\n  libraries?: string;\n  solutionChannel?: string;\n  authReferrerPolicy?: string;\n};\n\n// Declare global maps callback function\ndeclare global {\n  interface Window {\n    __googleMapsCallback__?: () => void;\n    gm_authFailure?: () => void;\n  }\n}\n\nconst MAPS_API_BASE_URL = 'https://maps.googleapis.com/maps/api/js';\n\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */\nexport class GoogleMapsApiLoader {\n  public static loadingStatus: APILoadingStatus = APILoadingStatus.NOT_LOADED;\n  public static serializedApiParams?: string;\n\n  /**\n   * Loads the Google Maps API with the specified parameters.\n   * Since the Maps library can only be loaded once per page, this will\n   * produce a warning when called multiple times with different\n   * parameters.\n   *\n   * The returned promise resolves when loading completes\n   * and rejects in case of an error or when the loading was aborted.\n   */\n  static async load(\n    params: ApiParams,\n    onLoadingStatusChange: (status: APILoadingStatus) => void\n  ): Promise<void> {\n    const libraries = params.libraries ? params.libraries.split(',') : [];\n    const serializedParams = this.serializeParams(params);\n\n    // note: if google.maps.importLibrary was defined externally, the params\n    //   will be ignored. If it was defined by a previous call to this\n    //   method, we will check that the key and other parameters have not been\n    //   changed in between calls.\n\n    if (!window.google?.maps?.importLibrary) {\n      this.serializedApiParams = serializedParams;\n      this.initImportLibrary(params, onLoadingStatusChange);\n    } else {\n      // if serializedApiParams isn't defined the library was loaded externally\n      // and we can only assume that went alright.\n      if (!this.serializedApiParams) {\n        this.loadingStatus = APILoadingStatus.LOADED;\n      }\n\n      onLoadingStatusChange(this.loadingStatus);\n    }\n\n    if (\n      this.serializedApiParams &&\n      this.serializedApiParams !== serializedParams\n    ) {\n      console.warn(\n        `The maps API has already been loaded with different ` +\n          `parameters and will not be loaded again. Refresh the page for ` +\n          `new values to have effect.`\n      );\n    }\n\n    for (const lib of ['maps', ...libraries]) {\n      await google.maps.importLibrary(lib);\n    }\n  }\n\n  private static serializeParams(params: ApiParams): string {\n    return [\n      params.v,\n      params.key,\n      params.language,\n      params.region,\n      params.authReferrerPolicy,\n      params.solutionChannel\n    ].join('/');\n  }\n\n  private static initImportLibrary(\n    params: ApiParams,\n    onLoadingStatusChange: (status: APILoadingStatus) => void\n  ) {\n    if (!window.google) window.google = {} as never;\n    if (!window.google.maps) window.google.maps = {} as never;\n\n    if (window.google.maps['importLibrary']) {\n      console.warn('initImportLibrary can only be called once.', params);\n\n      return;\n    }\n\n    let apiPromise: Promise<void> | null = null;\n\n    const loadApi = (library: string) => {\n      if (apiPromise) return apiPromise;\n\n      apiPromise = new Promise((resolve, reject) => {\n        const scriptElement = document.createElement('script');\n        const urlParams = new URLSearchParams();\n\n        for (const [key, value] of Object.entries(params)) {\n          const urlParamName = key.replace(\n            /[A-Z]/g,\n            t => '_' + t[0].toLowerCase()\n          );\n          urlParams.set(urlParamName, value);\n        }\n        urlParams.set('libraries', library);\n        urlParams.set('callback', '__googleMapsCallback__');\n        scriptElement.src = MAPS_API_BASE_URL + `?` + urlParams.toString();\n\n        window.__googleMapsCallback__ = () => {\n          this.loadingStatus = APILoadingStatus.LOADED;\n          onLoadingStatusChange(this.loadingStatus);\n          resolve();\n        };\n\n        window.gm_authFailure = () => {\n          this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n          onLoadingStatusChange(this.loadingStatus);\n        };\n\n        scriptElement.onerror = () => {\n          this.loadingStatus = APILoadingStatus.FAILED;\n          onLoadingStatusChange(this.loadingStatus);\n          reject(new Error('The Google Maps JavaScript API could not load.'));\n        };\n\n        scriptElement.nonce =\n          (document.querySelector('script[nonce]') as HTMLScriptElement)\n            ?.nonce || '';\n\n        this.loadingStatus = APILoadingStatus.LOADING;\n        onLoadingStatusChange(this.loadingStatus);\n        document.head.append(scriptElement);\n      });\n\n      return apiPromise;\n    };\n\n    // for the first load, we declare an importLibrary function that will\n    // be overwritten once the api is loaded.\n    google.maps.importLibrary = libraryName =>\n      loadApi(libraryName).then(() => google.maps.importLibrary(libraryName));\n  }\n}\n","import React, {\n  PropsWithChildren,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useState\n} from 'react';\n\nimport {GoogleMapsApiLoader} from '../libraries/google-maps-api-loader';\nimport {APILoadingStatus} from '../libraries/api-loading-status';\n\ntype ImportLibraryFunction = typeof google.maps.importLibrary;\ntype GoogleMapsLibrary = Awaited<ReturnType<ImportLibraryFunction>>;\ntype LoadedLibraries = {[name: string]: GoogleMapsLibrary};\n\nexport interface APIProviderContextValue {\n  status: APILoadingStatus;\n  loadedLibraries: LoadedLibraries;\n  importLibrary: typeof google.maps.importLibrary;\n  mapInstances: Record<string, google.maps.Map>;\n  addMapInstance: (map: google.maps.Map, id?: string) => void;\n  removeMapInstance: (id?: string) => void;\n  clearMapInstances: () => void;\n}\n\nexport const APIProviderContext =\n  React.createContext<APIProviderContextValue | null>(null);\n\nexport type APIProviderProps = {\n  /**\n   * apiKey must be provided to load the Google Maps JavaScript API. To create an API key, see: https://developers.google.com/maps/documentation/javascript/get-api-key\n   * Part of:\n   */\n  apiKey: string;\n  /**\n   * A custom id to reference the script tag can be provided. The default is set to 'google-maps-api'\n   * @default 'google-maps-api'\n   */\n  libraries?: Array<string>;\n  /**\n   * A specific version of the Google Maps JavaScript API can be used.\n   * Read more about versioning: https://developers.google.com/maps/documentation/javascript/versions\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  version?: string;\n  /**\n   * Sets the map to a specific region.\n   * Read more about localizing the Map: https://developers.google.com/maps/documentation/javascript/localization\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  region?: string;\n  /**\n   * Use a specific language for the map.\n   * Read more about localizing the Map: https://developers.google.com/maps/documentation/javascript/localization\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  language?: string;\n  /**\n   * auth_referrer_policy can be set to 'origin'.\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  authReferrerPolicy?: string;\n  /**\n   * A function that can be used to execute code after the Google Maps JavaScript API has been loaded.\n   */\n  onLoad?: () => void;\n};\n\n/**\n * local hook to set up the map-instance management context.\n */\nfunction useMapInstances() {\n  const [mapInstances, setMapInstances] = useState<\n    Record<string, google.maps.Map>\n  >({});\n\n  const addMapInstance = (mapInstance: google.maps.Map, id = 'default') => {\n    setMapInstances(instances => ({...instances, [id]: mapInstance}));\n  };\n\n  const removeMapInstance = (id = 'default') => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setMapInstances(({[id]: _, ...remaining}) => remaining);\n  };\n\n  const clearMapInstances = () => {\n    setMapInstances({});\n  };\n\n  return {mapInstances, addMapInstance, removeMapInstance, clearMapInstances};\n}\n\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */\nfunction useGoogleMapsApiLoader(props: APIProviderProps) {\n  const {onLoad, apiKey, libraries = [], ...otherApiParams} = props;\n\n  const [status, setStatus] = useState<APILoadingStatus>(\n    GoogleMapsApiLoader.loadingStatus\n  );\n  const [loadedLibraries, addLoadedLibrary] = useReducer(\n    (\n      loadedLibraries: LoadedLibraries,\n      action: {name: keyof LoadedLibraries; value: LoadedLibraries[string]}\n    ) => {\n      return {...loadedLibraries, [action.name]: action.value};\n    },\n    {}\n  );\n\n  const librariesString = useMemo(() => libraries?.join(','), [libraries]);\n  const serializedParams = useMemo(\n    () => JSON.stringify(otherApiParams),\n    [otherApiParams]\n  );\n\n  const importLibrary: typeof google.maps.importLibrary = useCallback(\n    async (name: string) => {\n      if (loadedLibraries[name]) {\n        return loadedLibraries[name];\n      }\n\n      if (!google?.maps?.importLibrary) {\n        throw new Error(\n          '[api-provider-internal] importLibrary was called before ' +\n            'google.maps.importLibrary was defined.'\n        );\n      }\n\n      const res = await window.google.maps.importLibrary(name);\n      addLoadedLibrary({name, value: res});\n\n      return res;\n    },\n    [loadedLibraries]\n  );\n\n  useEffect(\n    () => {\n      (async () => {\n        try {\n          await GoogleMapsApiLoader.load(\n            {\n              key: apiKey,\n              libraries: librariesString,\n              ...otherApiParams\n            },\n            status => setStatus(status)\n          );\n\n          for (const name of ['core', 'maps', ...libraries]) {\n            await importLibrary(name);\n          }\n\n          if (onLoad) {\n            onLoad();\n          }\n        } catch (error) {\n          console.error('<ApiProvider> failed to load Google Maps API', error);\n        }\n      })();\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [apiKey, librariesString, serializedParams]\n  );\n\n  return {\n    status,\n    loadedLibraries,\n    importLibrary\n  };\n}\n\n/**\n * Component to wrap the Google Maps React components and load the Google Maps JavaScript API\n */\nexport const APIProvider = (\n  props: PropsWithChildren<APIProviderProps>\n): ReactElement | null => {\n  const {children, ...loaderProps} = props;\n  const {mapInstances, addMapInstance, removeMapInstance, clearMapInstances} =\n    useMapInstances();\n\n  const {status, loadedLibraries, importLibrary} =\n    useGoogleMapsApiLoader(loaderProps);\n\n  return (\n    <APIProviderContext.Provider\n      value={{\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances,\n        status,\n        loadedLibraries,\n        importLibrary\n      }}>\n      {children}\n    </APIProviderContext.Provider>\n  );\n};\n","import {useContext} from 'react';\nimport {APIProviderContext} from '../components/api-provider';\nimport {APILoadingStatus} from '../libraries/api-loading-status';\n\nexport function useApiLoadingStatus(): APILoadingStatus {\n  return useContext(APIProviderContext)?.status || APILoadingStatus.NOT_LOADED;\n}\n","import {useApiLoadingStatus} from './use-api-loading-status';\nimport {APILoadingStatus} from '../libraries/api-loading-status';\n/**\n * Hook to check if the Google Maps API is loaded\n */\nexport function useApiIsLoaded(): boolean {\n  const status = useApiLoadingStatus();\n\n  return status === APILoadingStatus.LOADED;\n}\n","const shownMessages = new Set();\n\nexport function logErrorOnce(...args: Parameters<typeof console.error>) {\n  const key = JSON.stringify(args);\n\n  if (!shownMessages.has(key)) {\n    shownMessages.add(key);\n\n    console.error(...args);\n  }\n}\n","import {Ref, useCallback, useState} from 'react';\n\nexport function useCallbackRef<T>() {\n  const [el, setEl] = useState<T | null>(null);\n  const ref = useCallback((value: T) => setEl(value), [setEl]);\n\n  return [el, ref as Ref<T>] as const;\n}\n","import {MutableRefObject, useRef} from 'react';\nimport {MapCameraChangedEvent, MapEvent} from './use-map-events';\n\nexport type InternalCameraState = {\n  center: google.maps.LatLngLiteral;\n  heading: number;\n  tilt: number;\n  zoom: number;\n};\n\nexport type InternalCameraStateRef = MutableRefObject<InternalCameraState>;\n\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is updated by `trackDispatchedEvent` and used in `useMapOptions`.\n */\nexport function useInternalCameraState(): InternalCameraStateRef {\n  return useRef<InternalCameraState>({\n    center: {lat: 0, lng: 0},\n    heading: 0,\n    tilt: 0,\n    zoom: 0\n  });\n}\n\n/**\n * Records camera data from the last event dispatched to the React application\n * in a mutable `IternalCameraStateRef`.\n * This data can then be used to prevent feeding these values back to the\n * map-instance when a typical \"controlled component\" setup (state variable is\n * fed into and updated by the map).\n */\nexport function trackDispatchedEvent(\n  ev: MapEvent,\n  cameraStateRef: InternalCameraStateRef\n) {\n  const cameraEvent = ev as MapCameraChangedEvent;\n\n  // we're only interested in the camera-events here\n  if (!cameraEvent.detail.center) return;\n  const {center, zoom, heading, tilt} = cameraEvent.detail;\n\n  cameraStateRef.current.center = center;\n  cameraStateRef.current.heading = heading;\n  cameraStateRef.current.tilt = tilt;\n  cameraStateRef.current.zoom = zoom;\n}\n","import {useEffect} from 'react';\nimport {\n  InternalCameraStateRef,\n  trackDispatchedEvent\n} from './use-internal-camera-state';\n\n/**\n * Handlers for all events that could be emitted by map-instances.\n */\nexport type MapEventProps = Partial<{\n  // map view state events\n  onBoundsChanged: (event: MapCameraChangedEvent) => void;\n  onCenterChanged: (event: MapCameraChangedEvent) => void;\n  onHeadingChanged: (event: MapCameraChangedEvent) => void;\n  onTiltChanged: (event: MapCameraChangedEvent) => void;\n  onZoomChanged: (event: MapCameraChangedEvent) => void;\n  onProjectionChanged: (event: MapCameraChangedEvent) => void;\n\n  // mouse / touch / pointer events\n  onClick: (event: MapMouseEvent) => void;\n  onDblclick: (event: MapMouseEvent) => void;\n  onContextmenu: (event: MapMouseEvent) => void;\n  onMousemove: (event: MapMouseEvent) => void;\n  onMouseover: (event: MapMouseEvent) => void;\n  onMouseout: (event: MapMouseEvent) => void;\n  onDrag: (event: MapEvent) => void;\n  onDragend: (event: MapEvent) => void;\n  onDragstart: (event: MapEvent) => void;\n\n  // loading events\n  onTilesLoaded: (event: MapEvent) => void;\n  onIdle: (event: MapEvent) => void;\n\n  // configuration events\n  onIsFractionalZoomEnabledChanged: (event: MapEvent) => void;\n  onMapCapabilitiesChanged: (event: MapEvent) => void;\n  onMapTypeIdChanged: (event: MapEvent) => void;\n  onRenderingTypeChanged: (event: MapEvent) => void;\n}>;\n\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */\nexport function useMapEvents(\n  map: google.maps.Map | null,\n  cameraStateRef: InternalCameraStateRef,\n  props: MapEventProps\n) {\n  // note: calling a useEffect hook from within a loop is prohibited by the\n  // rules of hooks, but it's ok here since it's unconditional and the number\n  // and order of iterations is always strictly the same.\n  // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n\n  for (const propName of eventPropNames) {\n    // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n    //   a proper solution seems way too complicated right now\n    const handler = props[propName] as (ev: MapEvent) => void;\n    const eventType = propNameToEventType[propName];\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!map) return;\n      if (!handler) return;\n\n      const listener = google.maps.event.addListener(\n        map,\n        eventType,\n        (ev?: google.maps.MapMouseEvent | google.maps.IconMouseEvent) => {\n          const mapEvent = createMapEvent(eventType, map, ev);\n\n          trackDispatchedEvent(mapEvent, cameraStateRef);\n          handler(mapEvent);\n        }\n      );\n\n      return () => listener.remove();\n    }, [map, cameraStateRef, eventType, handler]);\n  }\n}\n\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */\nfunction createMapEvent(\n  type: string,\n  map: google.maps.Map,\n  srcEvent?: google.maps.MapMouseEvent | google.maps.IconMouseEvent\n): MapEvent {\n  const ev: MapEvent = {\n    type,\n    map,\n    detail: {},\n    stoppable: false,\n    stop: () => {}\n  };\n\n  if (cameraEventTypes.includes(type)) {\n    const camEvent = ev as MapCameraChangedEvent;\n\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n      console.warn(\n        '[createEvent] at least one of the values from the map ' +\n          'returned undefined. This is not expected to happen. Please ' +\n          'report an issue at https://github.com/visgl/react-google-maps/issues/new'\n      );\n    }\n\n    camEvent.detail = {\n      center: center?.toJSON() || {lat: 0, lng: 0},\n      zoom: zoom as number,\n      heading: heading as number,\n      tilt: tilt as number,\n      bounds: bounds?.toJSON() || {\n        north: 90,\n        east: 180,\n        south: -90,\n        west: -180\n      }\n    };\n\n    return camEvent;\n  } else if (mouseEventTypes.includes(type)) {\n    if (!srcEvent)\n      throw new Error('[createEvent] mouse events must provide a srcEvent');\n    const mouseEvent = ev as MapMouseEvent;\n\n    mouseEvent.domEvent = srcEvent.domEvent;\n    mouseEvent.stoppable = true;\n    mouseEvent.stop = () => srcEvent.stop();\n\n    mouseEvent.detail = {\n      latLng: srcEvent.latLng?.toJSON() || null,\n      placeId: (srcEvent as google.maps.IconMouseEvent).placeId\n    };\n\n    return mouseEvent;\n  }\n\n  return ev;\n}\n\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */\nconst propNameToEventType: {[prop in keyof Required<MapEventProps>]: string} = {\n  onBoundsChanged: 'bounds_changed',\n  onCenterChanged: 'center_changed',\n  onClick: 'click',\n  onContextmenu: 'contextmenu',\n  onDblclick: 'dblclick',\n  onDrag: 'drag',\n  onDragend: 'dragend',\n  onDragstart: 'dragstart',\n  onHeadingChanged: 'heading_changed',\n  onIdle: 'idle',\n  onIsFractionalZoomEnabledChanged: 'isfractionalzoomenabled_changed',\n  onMapCapabilitiesChanged: 'mapcapabilities_changed',\n  onMapTypeIdChanged: 'maptypeid_changed',\n  onMousemove: 'mousemove',\n  onMouseout: 'mouseout',\n  onMouseover: 'mouseover',\n  onProjectionChanged: 'projection_changed',\n  onRenderingTypeChanged: 'renderingtype_changed',\n  onTilesLoaded: 'tilesloaded',\n  onTiltChanged: 'tilt_changed',\n  onZoomChanged: 'zoom_changed'\n} as const;\n\nconst cameraEventTypes = [\n  'bounds_changed',\n  'center_changed',\n  'heading_changed',\n  'projection_changed',\n  'tilt_changed',\n  'zoom_changed'\n];\n\nconst mouseEventTypes = [\n  'click',\n  'contextmenu',\n  'dblclick',\n  'mousemove',\n  'mouseout',\n  'mouseover'\n];\n\ntype MapEventPropName = keyof MapEventProps;\nconst eventPropNames = Object.keys(propNameToEventType) as MapEventPropName[];\n\nexport type MapEvent<T = unknown> = {\n  type: string;\n  map: google.maps.Map;\n  detail: T;\n\n  stoppable: boolean;\n  stop: () => void;\n  domEvent?: MouseEvent | TouchEvent | PointerEvent | KeyboardEvent | Event;\n};\n\nexport type MapMouseEvent = MapEvent<{\n  latLng: google.maps.LatLngLiteral | null;\n  placeId: string | null;\n}>;\n\nexport type MapCameraChangedEvent = MapEvent<{\n  center: google.maps.LatLngLiteral;\n  bounds: google.maps.LatLngBoundsLiteral;\n  zoom: number;\n  heading: number;\n  tilt: number;\n}>;\n","export function isLatLngLiteral(\n  obj: unknown\n): obj is google.maps.LatLngLiteral {\n  if (!obj || typeof obj !== 'object') return false;\n  if (!('lat' in obj && 'lng' in obj)) return false;\n\n  return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\n","import {useEffect, useLayoutEffect} from 'react';\nimport {MapProps} from '@vis.gl/react-google-maps';\nimport {InternalCameraStateRef} from './use-internal-camera-state';\nimport {isLatLngLiteral} from '../../libraries/is-lat-lng-literal';\n\n/**\n * Internal hook to update the map-options and camera parameters when\n * props are changed.\n *\n * @param map the map instance\n * @param cameraStateRef stores the last values seen during dispatch into the\n * react-application in useMapEvents(). We can safely assume that we\n * don't need to feed these values back into the map.\n * @param mapProps the props to update the map-instance with\n * @internal\n */\nexport function useMapOptions(\n  map: google.maps.Map | null,\n  cameraStateRef: InternalCameraStateRef,\n  mapProps: MapProps\n) {\n  const {center: rawCenter, zoom, heading, tilt, ...mapOptions} = mapProps;\n  const center = rawCenter\n    ? isLatLngLiteral(rawCenter)\n      ? rawCenter\n      : rawCenter.toJSON()\n    : null;\n  const lat = center && center.lat;\n  const lng = center && center.lng;\n\n  /* eslint-disable react-hooks/exhaustive-deps --\n   *\n   * The following effects aren't triggered when the map is changed.\n   * In that case, the values will be or have been passed to the map\n   * constructor as mapOptions.\n   */\n\n  // update the map options when mapOptions is changed\n  // Note: due to the destructuring above, mapOptions will be seen as changed\n  //   with every re-render, so we're boldly assuming the maps-api will properly\n  //   deal with unchanged option-values passed into setOptions.\n  useEffect(() => {\n    if (!map) return;\n\n    // Changing the mapId via setOptions will trigger an error-message.\n    // We will re-create the map-instance in that case anyway, so we\n    // remove it here to avoid this error-message.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {mapId, ...opts} = mapOptions;\n    map.setOptions(opts);\n  }, [mapOptions]);\n\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(lat) || !Number.isFinite(lng)) return;\n    if (\n      cameraStateRef.current.center.lat === lat &&\n      cameraStateRef.current.center.lng === lng\n    )\n      return;\n\n    map.moveCamera({center: {lat: lat as number, lng: lng as number}});\n  }, [lat, lng]);\n\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(zoom)) return;\n    if (cameraStateRef.current.zoom === zoom) return;\n\n    map.moveCamera({zoom: zoom as number});\n  }, [zoom]);\n\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(heading)) return;\n    if (cameraStateRef.current.heading === heading) return;\n\n    map.moveCamera({heading: heading as number});\n  }, [heading]);\n\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(tilt)) return;\n    if (cameraStateRef.current.tilt === tilt) return;\n\n    map.moveCamera({tilt: tilt as number});\n  }, [tilt]);\n  /* eslint-enable react-hooks/exhaustive-deps */\n}\n","import {useLayoutEffect} from 'react';\n\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */\nexport function useDeckGLCameraUpdate(\n  map: google.maps.Map | null,\n  viewState: Record<string, unknown> | undefined\n) {\n  useLayoutEffect(() => {\n    if (!map || !viewState) {\n      return;\n    }\n\n    // FIXME: this should probably be extracted into a seperate hook that only\n    //  runs once when first seeing a deck.gl viewState update and resets\n    //  again. Maybe even use a seperate prop (`<Map controlled />`) instead.\n    map.setOptions({\n      gestureHandling: 'none',\n      keyboardShortcuts: false,\n      disableDefaultUI: true\n    });\n\n    const {\n      latitude,\n      longitude,\n      bearing: heading,\n      pitch: tilt,\n      zoom\n    } = viewState as Record<string, number>;\n\n    map.moveCamera({\n      center: {lat: latitude, lng: longitude},\n      heading,\n      tilt,\n      zoom: zoom + 1\n    });\n  }, [map, viewState]);\n}\n","/* eslint-disable complexity */\nimport React, {\n  CSSProperties,\n  PropsWithChildren,\n  Ref,\n  useContext,\n  useEffect,\n  useMemo,\n  useState\n} from 'react';\n\nimport {APIProviderContext, APIProviderContextValue} from '../api-provider';\n\nimport {useApiIsLoaded} from '../../hooks/use-api-is-loaded';\nimport {logErrorOnce} from '../../libraries/errors';\nimport {useCallbackRef} from '../../libraries/use-callback-ref';\nimport {MapEventProps, useMapEvents} from './use-map-events';\nimport {useMapOptions} from './use-map-options';\nimport {useDeckGLCameraUpdate} from './use-deckgl-camera-update';\nimport {useInternalCameraState} from './use-internal-camera-state';\nimport {useApiLoadingStatus} from '../../hooks/use-api-loading-status';\nimport {APILoadingStatus} from '../../libraries/api-loading-status';\n\nexport interface GoogleMapsContextValue {\n  map: google.maps.Map | null;\n}\nexport const GoogleMapsContext =\n  React.createContext<GoogleMapsContextValue | null>(null);\n\nexport type {\n  MapCameraChangedEvent,\n  MapEvent,\n  MapEventProps,\n  MapMouseEvent\n} from './use-map-events';\n\n/**\n * Props for the Google Maps Map Component\n */\nexport type MapProps = google.maps.MapOptions &\n  MapEventProps & {\n    style?: CSSProperties;\n    /**\n     * Adds custom style to the map by passing a css class.\n     */\n    className?: string;\n    /**\n     * Adds initial bounds to the map as an alternative to specifying the center/zoom of the map.\n     * Calls the fitBounds method internally https://developers.google.com/maps/documentation/javascript/reference/map?hl=en#Map-Methods\n     */\n    initialBounds?: google.maps.LatLngBounds | google.maps.LatLngBoundsLiteral;\n    /**\n     * An id that is added to the map. Needed when using more than one Map component.\n     * This is also needed to reference the map inside the useMap hook.\n     */\n    id?: string;\n    /**\n     * Viewport from deck.gl\n     */\n    viewport?: unknown;\n    /**\n     * View state from deck.gl\n     */\n    viewState?: Record<string, unknown>;\n    /**\n     * Initial View State from deck.gl\n     */\n    initialViewState?: Record<string, unknown>;\n  };\n\n/**\n * Component to render a Google Maps map\n */\nexport const Map = (props: PropsWithChildren<MapProps>) => {\n  const {children, id, className, style, viewState, viewport} = props;\n\n  const context = useContext(APIProviderContext);\n  const loadingStatus = useApiLoadingStatus();\n\n  if (!context) {\n    throw new Error(\n      '<Map> can only be used inside an <ApiProvider> component.'\n    );\n  }\n\n  const [map, mapRef] = useMapInstance(props, context);\n  const cameraStateRef = useInternalCameraState();\n  useMapOptions(map, cameraStateRef, props);\n  useMapEvents(map, cameraStateRef, props);\n  useDeckGLCameraUpdate(map, viewState);\n\n  const isViewportSet = useMemo(() => Boolean(viewport), [viewport]);\n  const combinedStyle: CSSProperties = useMemo(\n    () => ({\n      width: '100%',\n      height: '100%',\n\n      // when using deckgl, the map should be sent to the back\n      zIndex: isViewportSet ? -1 : 0,\n      ...style\n    }),\n    [style, isViewportSet]\n  );\n\n  if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n    return (\n      <div\n        style={{position: 'relative', ...(className ? {} : combinedStyle)}}\n        className={className}>\n        <AuthFailureMessage />\n      </div>\n    );\n  }\n\n  return (\n    <div\n      ref={mapRef}\n      data-testid={'map'}\n      style={className ? undefined : combinedStyle}\n      className={className}\n      {...(id ? {id} : {})}>\n      {map ? (\n        <GoogleMapsContext.Provider value={{map}}>\n          {children}\n        </GoogleMapsContext.Provider>\n      ) : null}\n    </div>\n  );\n};\nMap.deckGLViewProps = true;\n\nconst AuthFailureMessage = () => {\n  const style: CSSProperties = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    zIndex: 999,\n    display: 'flex',\n    flexFlow: 'column nowrap',\n    textAlign: 'center',\n    justifyContent: 'center',\n    fontSize: '.8rem',\n    color: 'rgba(0,0,0,0.6)',\n    background: '#dddddd',\n    padding: '1rem 1.5rem'\n  };\n\n  return (\n    <div style={style}>\n      <h2>Error: AuthFailure</h2>\n      <p>\n        A problem with your API key prevents the map from rendering correctly.\n        Please make sure the value of the <code>APIProvider.apiKey</code> prop\n        is correct. Check the error-message in the console for further details.\n      </p>\n    </div>\n  );\n};\n\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */\nfunction useMapInstance(\n  props: MapProps,\n  context: APIProviderContextValue\n): readonly [map: google.maps.Map | null, containerRef: Ref<HTMLDivElement>] {\n  const apiIsLoaded = useApiIsLoaded();\n  const [map, setMap] = useState<google.maps.Map | null>(null);\n  const [container, containerRef] = useCallbackRef<HTMLDivElement>();\n\n  const {\n    id,\n    initialBounds,\n\n    ...mapOptions\n  } = props;\n\n  // create the map instance and register it in the context\n  useEffect(\n    () => {\n      if (!container || !apiIsLoaded) return;\n\n      const {addMapInstance, removeMapInstance} = context;\n      const newMap = new google.maps.Map(container, mapOptions);\n      setMap(newMap);\n      addMapInstance(newMap, id);\n\n      if (initialBounds) {\n        newMap.fitBounds(initialBounds);\n      }\n\n      return () => {\n        if (!container || !apiIsLoaded) return;\n\n        // remove all event-listeners to minimize memory-leaks\n        google.maps.event.clearInstanceListeners(newMap);\n\n        setMap(null);\n        removeMapInstance(id);\n      };\n    },\n\n    // FIXME: we should rethink if it could be possible to keep the state\n    //   around when a map gets re-initialized (id or mapId changed). This\n    //   should keep the viewport as it is (so also no initial viewport in\n    //   this case) and any added features should of course get re-added as\n    //   well.\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [id, container, apiIsLoaded, props.mapId]\n  );\n\n  // report an error if the same map-id is used multiple times\n  useEffect(() => {\n    if (!id) return;\n\n    const {mapInstances} = context;\n\n    if (mapInstances[id] && mapInstances[id] !== map) {\n      logErrorOnce(\n        `The map id '${id}' seems to have been used multiple times. ` +\n          'This can lead to unexpected problems when accessing the maps. ' +\n          'Please use unique ids for all <Map> components.'\n      );\n    }\n  }, [id, context, map]);\n\n  return [map, containerRef] as const;\n}\n","import {useContext, useEffect} from 'react';\n\nimport {APIProviderContext} from '../components/api-provider';\nimport {useApiIsLoaded} from './use-api-is-loaded';\n\ninterface ApiLibraries {\n  core: google.maps.CoreLibrary;\n  maps: google.maps.MapsLibrary;\n  places: google.maps.PlacesLibrary;\n  geocoding: google.maps.GeocodingLibrary;\n  routes: google.maps.RoutesLibrary;\n  marker: google.maps.MarkerLibrary;\n  geometry: google.maps.GeometryLibrary;\n  elevation: google.maps.ElevationLibrary;\n  streetView: google.maps.StreetViewLibrary;\n  journeySharing: google.maps.JourneySharingLibrary;\n  drawing: google.maps.DrawingLibrary;\n  visualization: google.maps.VisualizationLibrary;\n}\n\nexport function useMapsLibrary<\n  K extends keyof ApiLibraries,\n  V extends ApiLibraries[K]\n>(name: K): V | null;\n\nexport function useMapsLibrary(name: string) {\n  const apiIsLoaded = useApiIsLoaded();\n  const ctx = useContext(APIProviderContext);\n\n  useEffect(() => {\n    if (!apiIsLoaded || !ctx) return;\n\n    // Trigger loading the libraries via our proxy-method.\n    // The returned promise is ignored, since importLibrary will update loadedLibraries\n    // list in the context, triggering a re-render.\n    void ctx.importLibrary(name);\n  }, [apiIsLoaded, ctx?.importLibrary]);\n\n  return ctx?.loadedLibraries[name] || null;\n}\n","/* eslint-disable complexity */\nimport React, {\n  Children,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useState\n} from 'react';\n\nimport {createPortal} from 'react-dom';\nimport {GoogleMapsContext} from './map';\n\nimport type {Ref, PropsWithChildren} from 'react';\nimport {useMapsLibrary} from '../hooks/use-maps-library';\n\nexport interface AdvancedMarkerContextValue {\n  marker: google.maps.marker.AdvancedMarkerElement;\n}\n\nexport const AdvancedMarkerContext =\n  React.createContext<AdvancedMarkerContextValue | null>(null);\n\ntype AdvancedMarkerEventProps = {\n  onClick?: (e: google.maps.MapMouseEvent) => void;\n  onDrag?: (e: google.maps.MapMouseEvent) => void;\n  onDragStart?: (e: google.maps.MapMouseEvent) => void;\n  onDragEnd?: (e: google.maps.MapMouseEvent) => void;\n};\n\nexport type AdvancedMarkerProps = PropsWithChildren<\n  Omit<google.maps.marker.AdvancedMarkerElementOptions, 'gmpDraggable'> &\n    AdvancedMarkerEventProps & {\n      /**\n       * className to add a class to the advanced marker element\n       * Can only be used with HTML Marker content\n       */\n      className?: string;\n      draggable?: boolean;\n    }\n>;\n\nexport type AdvancedMarkerRef = google.maps.marker.AdvancedMarkerElement | null;\nfunction useAdvancedMarker(props: AdvancedMarkerProps) {\n  const [marker, setMarker] =\n    useState<google.maps.marker.AdvancedMarkerElement | null>(null);\n  const [contentContainer, setContentContainer] =\n    useState<HTMLDivElement | null>(null);\n\n  const map = useContext(GoogleMapsContext)?.map;\n  const markerLibrary = useMapsLibrary('marker');\n\n  const {\n    children,\n    className,\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    collisionBehavior,\n    draggable,\n    position,\n    title,\n    zIndex\n  } = props;\n\n  const numChilds = Children.count(children);\n\n  // create marker instance and add it to the map when map becomes available\n  useEffect(() => {\n    if (!map || !markerLibrary) return;\n\n    const newMarker = new markerLibrary.AdvancedMarkerElement();\n    newMarker.map = map;\n\n    setMarker(newMarker);\n\n    // create container for marker content if there are children\n    if (numChilds > 0) {\n      const el = document.createElement('div');\n      if (className) el.className = className;\n\n      newMarker.content = el;\n\n      setContentContainer(el);\n    }\n\n    return () => {\n      newMarker.map = null;\n      setMarker(null);\n      setContentContainer(null);\n    };\n  }, [map, markerLibrary, numChilds]);\n\n  // bind all marker events\n  useEffect(() => {\n    if (!marker) return;\n\n    const gme = google.maps.event;\n\n    if (onClick) gme.addListener(marker, 'click', onClick);\n    if (onDrag) gme.addListener(marker, 'drag', onDrag);\n    if (onDragStart) gme.addListener(marker, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(marker, 'dragend', onDragEnd);\n\n    if ((onDrag || onDragStart || onDragEnd) && !draggable) {\n      console.warn(\n        'You need to set the marker to draggable to listen to drag-events.'\n      );\n    }\n\n    const m = marker;\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [marker, draggable, onClick, onDragStart, onDrag, onDragEnd]);\n\n  // update other marker props when changed\n  useEffect(() => {\n    if (!marker) return;\n\n    if (position !== undefined) marker.position = position;\n    if (draggable !== undefined) marker.gmpDraggable = draggable;\n    if (collisionBehavior !== undefined)\n      marker.collisionBehavior = collisionBehavior;\n    if (zIndex !== undefined) marker.zIndex = zIndex;\n    if (typeof title === 'string') marker.title = title;\n  }, [marker, position, draggable, collisionBehavior, zIndex, title]);\n\n  return [marker, contentContainer] as const;\n}\n\nexport const AdvancedMarker = forwardRef(\n  (props: AdvancedMarkerProps, ref: Ref<AdvancedMarkerRef>) => {\n    const {children} = props;\n    const [marker, contentContainer] = useAdvancedMarker(props);\n\n    useImperativeHandle(ref, () => marker, [marker]);\n\n    if (!marker) {\n      return null;\n    }\n\n    return (\n      <AdvancedMarkerContext.Provider value={{marker}}>\n        {contentContainer !== null && createPortal(children, contentContainer)}\n      </AdvancedMarkerContext.Provider>\n    );\n  }\n);\n\nexport function useAdvancedMarkerRef() {\n  const [marker, setMarker] =\n    useState<google.maps.marker.AdvancedMarkerElement | null>(null);\n\n  const refCallback = useCallback((m: AdvancedMarkerRef | null) => {\n    setMarker(m);\n  }, []);\n\n  return [refCallback, marker] as const;\n}\n","/* eslint-disable complexity */\nimport React, {PropsWithChildren, useContext, useEffect, useState} from 'react';\nimport {createPortal} from 'react-dom';\n\nimport {GoogleMapsContext} from './map';\n\n/**\n * Props for the Info Window Component\n */\nexport type InfoWindowProps = google.maps.InfoWindowOptions & {\n  onCloseClick?: () => void;\n  anchor?: google.maps.Marker | google.maps.marker.AdvancedMarkerElement | null;\n};\n\n/**\n * Component to render a Google Maps Info Window\n */\nexport const InfoWindow = (props: PropsWithChildren<InfoWindowProps>) => {\n  const {children, anchor, onCloseClick, ...infoWindowOptions} = props;\n  const map = useContext(GoogleMapsContext)?.map;\n\n  const [contentContainer, setContentContainer] =\n    useState<HTMLDivElement | null>(null);\n\n  // create infowindow once map is available\n  useEffect(() => {\n    if (!map) return;\n\n    const infoWindow = new google.maps.InfoWindow(infoWindowOptions);\n\n    // Add content to info window\n    const el = document.createElement('div');\n    infoWindow.setContent(el);\n    infoWindow.open({map, anchor});\n\n    if (onCloseClick) {\n      google.maps.event.addListener(infoWindow, 'closeclick', () => {\n        onCloseClick();\n      });\n    }\n\n    setContentContainer(el);\n\n    // Cleanup info window and event listeners on unmount\n    return () => {\n      google.maps.event.clearInstanceListeners(infoWindow);\n\n      infoWindow.close();\n      el.remove();\n\n      setContentContainer(null);\n    };\n  }, [map, children, anchor]);\n\n  return (\n    <>{contentContainer !== null && createPortal(children, contentContainer)}</>\n  );\n};\n","import {useContext} from 'react';\n\nimport {APIProviderContext} from '../components/api-provider';\nimport {GoogleMapsContext} from '../components/map';\nimport {logErrorOnce} from '../libraries/errors';\n\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */\nexport const useMap = (id: string | null = null): google.maps.Map | null => {\n  const ctx = useContext(APIProviderContext);\n  const {map} = useContext(GoogleMapsContext) || {};\n\n  if (ctx === null) {\n    logErrorOnce(\n      'useMap(): failed to retrieve APIProviderContext. ' +\n        'Make sure that the <APIProvider> component exists and that the ' +\n        'component you are calling `useMap()` from is a sibling of the ' +\n        '<APIProvider>.'\n    );\n\n    return null;\n  }\n\n  const {mapInstances} = ctx;\n\n  // if an id is specified, the corresponding map or null is returned\n  if (id !== null) return mapInstances[id] || null;\n\n  // otherwise, return the closest ancestor\n  if (map) return map;\n\n  // finally, return the default map instance\n  return mapInstances['default'] || null;\n};\n","import {useEffect, useMemo} from 'react';\nimport {createPortal} from 'react-dom';\nimport {useMap} from '../hooks/use-map';\n\nimport type {PropsWithChildren} from 'react';\n\ntype MapControlProps = PropsWithChildren<{\n  position: ControlPosition;\n}>;\n\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nexport const ControlPosition = {\n  TOP_LEFT: 1,\n  TOP_CENTER: 2,\n  TOP: 2,\n  TOP_RIGHT: 3,\n  LEFT_CENTER: 4,\n  LEFT_TOP: 5,\n  LEFT: 5,\n  LEFT_BOTTOM: 6,\n  RIGHT_TOP: 7,\n  RIGHT: 7,\n  RIGHT_CENTER: 8,\n  RIGHT_BOTTOM: 9,\n  BOTTOM_LEFT: 10,\n  BOTTOM_CENTER: 11,\n  BOTTOM: 11,\n  BOTTOM_RIGHT: 12,\n  CENTER: 13,\n  BLOCK_START_INLINE_START: 14,\n  BLOCK_START_INLINE_CENTER: 15,\n  BLOCK_START_INLINE_END: 16,\n  INLINE_START_BLOCK_CENTER: 17,\n  INLINE_START_BLOCK_START: 18,\n  INLINE_START_BLOCK_END: 19,\n  INLINE_END_BLOCK_START: 20,\n  INLINE_END_BLOCK_CENTER: 21,\n  INLINE_END_BLOCK_END: 22,\n  BLOCK_END_INLINE_START: 23,\n  BLOCK_END_INLINE_CENTER: 24,\n  BLOCK_END_INLINE_END: 25\n} as const;\nexport type ControlPosition =\n  (typeof ControlPosition)[keyof typeof ControlPosition];\n\nexport const MapControl = ({children, position}: MapControlProps) => {\n  const controlContainer = useMemo(() => document.createElement('div'), []);\n  const map = useMap();\n\n  useEffect(() => {\n    if (!map) return;\n\n    const controls = map.controls[position];\n\n    controls.push(controlContainer);\n\n    return () => {\n      const index = controls.getArray().indexOf(controlContainer);\n      controls.removeAt(index);\n    };\n  }, [map, position]);\n\n  return createPortal(children, controlContainer);\n};\n","/* eslint-disable complexity */\nimport React, {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useState\n} from 'react';\n\nimport {GoogleMapsContext} from './map';\n\nimport type {Ref} from 'react';\n\ntype MarkerEventProps = {\n  onClick?: (e: google.maps.MapMouseEvent) => void;\n  onDrag?: (e: google.maps.MapMouseEvent) => void;\n  onDragStart?: (e: google.maps.MapMouseEvent) => void;\n  onDragEnd?: (e: google.maps.MapMouseEvent) => void;\n  onMouseOver?: (e: google.maps.MapMouseEvent) => void;\n  onMouseOut?: (e: google.maps.MapMouseEvent) => void;\n};\n\nexport type MarkerProps = google.maps.MarkerOptions & MarkerEventProps;\n\nexport type MarkerRef = Ref<google.maps.Marker | null>;\n\nfunction useMarker(props: MarkerProps) {\n  const [marker, setMarker] = useState<google.maps.Marker | null>(null);\n  const map = useContext(GoogleMapsContext)?.map;\n\n  const {\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    onMouseOver,\n    onMouseOut,\n    ...markerOptions\n  } = props;\n\n  const {position, draggable} = markerOptions;\n\n  // create marker instance and add to the map once the map is available\n  useEffect(() => {\n    if (!map) {\n      if (map === undefined)\n        console.error('<Marker> has to be inside a Map component.');\n\n      return;\n    }\n\n    const newMarker = new google.maps.Marker(markerOptions);\n    newMarker.setMap(map);\n    setMarker(newMarker);\n\n    return () => {\n      newMarker.setMap(null);\n      setMarker(null);\n    };\n  }, [map]);\n\n  // attach and re-attach event-handlers when any of the properties change\n  useEffect(() => {\n    if (!marker) return;\n\n    const m = marker;\n\n    // Add event listeners\n    const gme = google.maps.event;\n\n    if (onClick) gme.addListener(m, 'click', onClick);\n    if (onDrag) gme.addListener(m, 'drag', onDrag);\n    if (onDragStart) gme.addListener(m, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(m, 'dragend', onDragEnd);\n    if (onMouseOver) gme.addListener(m, 'mouseover', onMouseOver);\n    if (onMouseOut) gme.addListener(m, 'mouseout', onMouseOut);\n\n    marker.setDraggable(Boolean(draggable));\n\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [\n    marker,\n    draggable,\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    onMouseOver,\n    onMouseOut\n  ]);\n\n  // update markerOptions (note the dependencies aren't properly checked\n  // here, we just assume that setOptions is smart enough to not waste a\n  // lot of time updating values that didn't change)\n  useEffect(() => {\n    if (!marker) return;\n    if (markerOptions) marker.setOptions(markerOptions);\n  }, [marker, markerOptions]);\n\n  // update position when changed\n  useEffect(() => {\n    // Should not update position when draggable\n    if (draggable || !position || !marker) return;\n\n    marker.setPosition(position);\n  }, [draggable, position, marker]);\n\n  return marker;\n}\n\n/**\n * Component to render a Google Maps Marker on a map\n */\nexport const Marker = forwardRef((props: MarkerProps, ref: MarkerRef) => {\n  const marker = useMarker(props);\n\n  useImperativeHandle(ref, () => marker, [marker]);\n\n  return <></>;\n});\n\nexport function useMarkerRef() {\n  const [marker, setMarker] = useState<google.maps.Marker | null>(null);\n\n  const refCallback = useCallback((m: google.maps.Marker | null) => {\n    setMarker(m);\n  }, []);\n\n  return [refCallback, marker] as const;\n}\n","import {\n  Children,\n  PropsWithChildren,\n  useContext,\n  useEffect,\n  useMemo\n} from 'react';\nimport {AdvancedMarkerContext} from './advanced-marker';\nimport {createPortal} from 'react-dom';\nimport {logErrorOnce} from '../libraries/errors';\n\n/**\n * Props for the Pin component\n */\nexport type PinProps = google.maps.marker.PinElementOptions;\n\n/**\n * Component to render a google maps marker Pin View\n */\nexport const Pin = (props: PropsWithChildren<PinProps>) => {\n  const advancedMarker = useContext(AdvancedMarkerContext)?.marker;\n  const glyphContainer = useMemo(() => document.createElement('div'), []);\n\n  // Create Pin View instance\n  useEffect(() => {\n    if (!advancedMarker) {\n      if (advancedMarker === undefined) {\n        console.error(\n          'The <Pin> component can only be used inside <AdvancedMarker>.'\n        );\n      }\n\n      return;\n    }\n\n    if (props.glyph && props.children) {\n      logErrorOnce(\n        'The <Pin> component only uses children to render the glyph if both the glyph property and children are present.'\n      );\n    }\n\n    if (Children.count(props.children) > 1) {\n      logErrorOnce(\n        'Passing multiple children to the <Pin> component might lead to unexpected results.'\n      );\n    }\n\n    const pinViewOptions: google.maps.marker.PinElementOptions = {\n      ...props\n    };\n\n    const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n\n    // Set glyph to glyph container if children are present (rendered via portal).\n    // If both props.glyph and props.children are present, props.children takes priority.\n    if (props.children) {\n      pinElement.glyph = glyphContainer;\n    }\n\n    // Set content of Advanced Marker View to the Pin View element\n    advancedMarker.content = pinElement.element;\n  }, [advancedMarker, props]);\n\n  return createPortal(props.children, glyphContainer);\n};\n","import {useState, useRef, useEffect} from 'react';\n\nimport {useApiIsLoaded} from './use-api-is-loaded';\n\nexport interface AutocompleteProps {\n  inputField: HTMLInputElement | null;\n  options?: google.maps.places.AutocompleteOptions;\n  onPlaceChanged: (place: google.maps.places.PlaceResult) => void;\n}\n\n/**\n * Hook to get a Google Maps Places Autocomplete instance\n * monitoring an input field\n */\nexport const useAutocomplete = (\n  props: AutocompleteProps\n): google.maps.places.Autocomplete | null => {\n  const {inputField, options, onPlaceChanged} = props;\n\n  const googleMapsAPIIsLoaded = useApiIsLoaded();\n\n  const placeChangedHandler = useRef(onPlaceChanged);\n\n  const [autocomplete, setAutocomplete] =\n    useState<google.maps.places.Autocomplete | null>(null);\n\n  // Initializes the Google Maps Places Autocomplete\n  useEffect(() => {\n    // Wait for the Google Maps API and input element to be initialized\n    if (!googleMapsAPIIsLoaded || !inputField) return;\n\n    // FIXME: add dynamic loading for required libraries\n    if (!google.maps.places) {\n      console.error(\n        'Google Maps Places library is missing. ' +\n          'Please add the places library to the props of the <ApiProvider> ' +\n          'component.'\n      );\n\n      return;\n    }\n\n    // Create Autocomplete instance\n    const autocompleteInstance = new google.maps.places.Autocomplete(\n      inputField,\n      options\n    );\n\n    setAutocomplete(autocompleteInstance);\n\n    // Add places change listener to Autocomplete\n    autocompleteInstance.addListener('place_changed', () => {\n      const place = autocompleteInstance.getPlace();\n      if (placeChangedHandler.current) placeChangedHandler.current(place);\n    });\n\n    // Clear listeners on unmount\n    return () => {\n      if (autocompleteInstance && typeof google.maps === 'object') {\n        google.maps.event.clearInstanceListeners(autocompleteInstance);\n      }\n    };\n  }, [googleMapsAPIIsLoaded, inputField, options]);\n\n  return autocomplete;\n};\n","/**\n * A typescript assertion function used in cases where typescript has to be\n * convinced that the object in question can not be null.\n *\n * @param value\n * @param message\n */\nexport function assertNotNull<TValue>(\n  value: TValue,\n  message = 'assertion failed'\n): asserts value is NonNullable<TValue> {\n  if (value === null || value === undefined) {\n    throw Error(message);\n  }\n}\n","import {useMemo, useEffect, useCallback} from 'react';\n\nimport {useApiIsLoaded} from './use-api-is-loaded';\nimport {useMap} from './use-map';\nimport {assertNotNull} from '../libraries/assert-not-null';\n\nexport interface DirectionsServiceHookOptions {\n  mapId?: string;\n  renderOnMap?: boolean;\n  renderOptions?: google.maps.DirectionsRendererOptions;\n}\n\ninterface DirectionsServiceHookReturns {\n  directionsService: google.maps.DirectionsService | null;\n  directionsRenderer: google.maps.DirectionsRenderer | null;\n  renderRoute:\n    | ((\n        request: google.maps.DirectionsRequest\n      ) => Promise<google.maps.DirectionsResult>)\n    | null;\n  setRenderedRouteIndex: ((index: number) => void) | null;\n}\n\nconst useDirectionsRenderer = (\n  mapId: string | null,\n  renderOnMap?: boolean,\n  renderOptions?: google.maps.DirectionsRendererOptions\n) => {\n  const map = useMap(mapId);\n\n  // create the renderer instance\n  const directionsRenderer = useMemo(\n    () => {\n      if (!map || !renderOnMap) return null;\n\n      const renderer = new google.maps.DirectionsRenderer(renderOptions);\n      renderer.setMap(map);\n\n      return renderer;\n    },\n    // note: no dependency on renderOptions since those are handled in the\n    // next effect.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [map, renderOnMap]\n  );\n\n  useEffect(\n    () => {\n      if (!directionsRenderer) return;\n\n      directionsRenderer.setOptions(renderOptions || {});\n    },\n    // note: directionsRenderer dependency isn't needed since the\n    // renderOptions will be set on initialization when creating the renderer.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [renderOptions]\n  );\n\n  return directionsRenderer;\n};\n\n/**\n * Hook to get Google Maps Places Directions Service instance\n */\nexport const useDirectionsService = (\n  props: DirectionsServiceHookOptions = {}\n): DirectionsServiceHookReturns => {\n  const {mapId = null, renderOnMap, renderOptions} = props;\n  const isApiLoaded = useApiIsLoaded();\n\n  // Creates a Directions Service instance\n  const directionsService = useMemo(() => {\n    // Wait for Google Maps API to be loaded\n    if (!isApiLoaded) return null;\n\n    return new google.maps.DirectionsService();\n  }, [isApiLoaded]);\n\n  // create the renderer instance\n  const directionsRenderer = useDirectionsRenderer(\n    mapId,\n    renderOnMap,\n    renderOptions\n  );\n\n  // Custom Directions route request followed by directions rendering\n  const renderRoute = useCallback(\n    async (\n      request: google.maps.DirectionsRequest\n    ): Promise<google.maps.DirectionsResult> => {\n      // findAndRenderRoute() isn't callable when either directions\n      // service or renderer aren't ready\n      assertNotNull(directionsService);\n      assertNotNull(directionsRenderer);\n\n      const result = await directionsService.route(request);\n      directionsRenderer.setDirections(result);\n\n      return result;\n    },\n    [directionsService, directionsRenderer]\n  );\n\n  // Renders directions route of given index\n  const setRenderedRouteIndex = (index: number) => {\n    assertNotNull(directionsRenderer);\n\n    directionsRenderer.setRouteIndex(index);\n  };\n\n  return {\n    directionsService,\n    directionsRenderer,\n    renderRoute: directionsService && directionsRenderer ? renderRoute : null,\n    setRenderedRouteIndex:\n      directionsService && directionsRenderer ? setRenderedRouteIndex : null\n  };\n};\n","/* eslint-disable complexity */\nimport {useEffect, useState} from 'react';\nimport {useApiIsLoaded} from './use-api-is-loaded';\nimport {useMap} from './use-map';\n\nexport interface StreetViewPanoramaProps {\n  mapId?: string;\n  divElement?: HTMLElement | null;\n  position?: google.maps.LatLng | google.maps.LatLngLiteral;\n  pov?: google.maps.StreetViewPov;\n  zoom?: number;\n}\n\n/**\n * Hook to get Street View Panorama\n */\nexport const useStreetViewPanorama = (\n  props: StreetViewPanoramaProps = {}\n): google.maps.StreetViewPanorama | null => {\n  const {mapId, divElement, position, pov, zoom} = props;\n  const googleMapsAPIIsLoaded = useApiIsLoaded();\n  const map = useMap(mapId);\n\n  const [streetViewPanorama, setStreetViewPanorama] =\n    useState<google.maps.StreetViewPanorama | null>(null);\n\n  // Creates a Street View instance\n  useEffect(\n    () => {\n      if (!googleMapsAPIIsLoaded) return;\n\n      let pano: google.maps.StreetViewPanorama | null = null;\n      if (divElement) {\n        pano = new google.maps.StreetViewPanorama(divElement);\n      } else if (map) {\n        pano = map.getStreetView();\n      }\n\n      setStreetViewPanorama(pano);\n\n      if (!pano) return;\n      if (pov) pano.setPov(pov);\n      if (position) pano.setPosition(position);\n      if (zoom || zoom === 0) pano.setZoom(zoom);\n\n      return (): void => {\n        setStreetViewPanorama(null);\n\n        if (map) map.setStreetView(null);\n      };\n    },\n    // fixme: implement extra hook to update FOV when props change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [googleMapsAPIIsLoaded, map, divElement]\n  );\n\n  return streetViewPanorama;\n};\n","const mapLinear = (x: number, a1: number, a2: number, b1: number, b2: number) =>\n  b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);\n\nconst getMapMaxTilt = (zoom: number) => {\n  if (zoom <= 10) {\n    return 30;\n  }\n  if (zoom >= 15.5) {\n    return 67.5;\n  }\n\n  // range [10...14]\n  if (zoom <= 14) {\n    return mapLinear(zoom, 10, 14, 30, 45);\n  }\n\n  // range [14...15.5]\n  return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n\n/**\n * Function to limit the tilt range of the google maps map when updating the view state\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const limitTiltRange = ({viewState}: any) => {\n  const pitch = viewState.pitch;\n  const gmZoom = viewState.zoom + 1;\n  const maxTilt = getMapMaxTilt(gmZoom);\n\n  return {...viewState, fovy: 25, pitch: Math.min(maxTilt, pitch)};\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}